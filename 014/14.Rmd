---
title: "Problem 1"
author: "Martin Stefan"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA)
```

Let's begin by writing a simple function which can generates the next value of a Collatz sequence:

```{r}
collatz <- function(n) {
  if (n %% 2 == 0) {
    return(n/2)
  } else {
    return(3*n+1)
  }
}
```

Here is how it works in action:

```{r}
n <- 13
while (n > 1) {
  print(n)
  n <- collatz(n)
}
```

Let's wrap this loop in a function that can generate the entire Collatz sequence:

```{r}
collatz_sequence <- function(n) {
  numbers <- c(n)
  while (n > 1) {
    n <- collatz(n)
    numbers <- c(numbers, n)
  }
  return(numbers)
}
```

Here are a few sequences:

```{r}
collatz_sequence(1)
collatz_sequence(5)
collatz_sequence(10)
```

At this stage, we could try to brute-force the problem. I am going to do this for starting values up to 1000:

```{r}
max_number <- NULL
max_length <- 0
for (i in 1:1000) {
  numbers <- collatz_sequence(i)
  if (length(numbers) > max_length) {
    max_length <- length(numbers)
    max_number <- i
  }
}
max_number
```

As we can see, among all starting numbers up to 1000, 871 produces the longest Collatz sequence. However, when running this brute-force approach for starging numbers up to 1,000,000, our computer may struggle. So, let's head back to the start and have a look at the following to sequences:

```{r}
collatz_sequence(5)
collatz_sequence(6)
```

Notice how the last six values of `collatz_sequence(6)` (5, 16, 8, 4, 2, 1) are the same as the sequence generated by `collatz_sequence(5)`. So when generating `collatz_sequence(6)` we could have just stopped at "5" because we had already established what comes after it. In fact, if we had run `collatz_sequence(3)` before, we could have even stopped at "3". 

So when generating sequences with consecutive starting values, we can always stop within a sequence, once we encounter a previous starting value. 

ADD EXPLANATION HERE !!!


```{r}

# create vector in which to store the sequence lengths
n_max <- 1e6
lengths <- rep(0, n_max)

# generate sequences for different starting values
for (start in 2:n_max) {
  n <- start
  count <- 0
  while (n != 1 & n >= start) {
    n <- collatz(n)
    count <- count + 1
  }
  count <- count + lengths[n]
  lengths[start] <- count
}
which.max(lengths)
```

CAN THE LOOP GO FROM 1:n_max instead of 2:n_max???

ADD FURTHER CODE IMPROVEMENTS (FOR BOTH EVEN AND OOD NUMBERS) DONE HERE!