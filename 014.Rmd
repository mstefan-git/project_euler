# 14: Longest Collatz sequence

The following iterative sequence is defined for the set of positive integers:

$$
n → ~ n/2 ~~~~~~ (n ~ \text{is even})
$$
$$
n → ~ 3n + 1 ~~~ (n ~ \text{is odd})
$$

Using the rule above and starting with 13, we generate the following sequence:

$$
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
$$

It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

Which starting number, under one million, produces the longest chain?

NOTE: Once the chain starts the terms are allowed to go above one million.


## Preliminaries

Let's begin by writing a simple function which can generates the next value of a Collatz sequence:
```{r}
collatz <- function(n) {
  if (n %% 2 == 0) {
    return(n/2)
  } else {
    return(3*n+1)
  }
}
```

Here is how it works in action:
```{r}
n <- 13
while (n > 1) {
  print(n)
  n <- collatz(n)
}
```

Notice that we only generate new values while `n > 1`. Otherwise, we would get stuck in the cycle $$1 → 4 → 2 → 1 →\cdots  ~.$$ Let's wrap our loop in a function that can generate the entire Collatz sequence for a given starting number:
```{r}
collatz_sequence <- function(n) {
  numbers <- c(n)
  while (n > 1) {
    n <- collatz(n)
    numbers <- c(numbers, n)
  }
  return(numbers)
}
```

Here are a few sequences:
```{r}
collatz_sequence(1)
collatz_sequence(5)
collatz_sequence(10)
```

## Brute force

At this stage, we could try to brute-force the problem. I am going to do this for starting values up to 1000:
```{r}
brute_force <- function(x) {
  max_number <- NULL
  max_length <- 0
  for (i in 1:x) {
    numbers <- collatz_sequence(i)
    if (length(numbers) > max_length) {
      max_length <- length(numbers)
      max_number <- i
    }
  }
  return(max_number)
}

brute_force(1000)
```

As we can see, among all starting numbers up to 1000, 871 produces the longest Collatz sequence. However, when running this brute-force approach for starting numbers up to 1,000,000, our computer may struggle. 

## Optimization

Let's head back to the start and have a look at the following two sequences:
```{r}
collatz_sequence(5)
collatz_sequence(6)
```

Notice how the last six values of `collatz_sequence(6)` (i.e., 5, 16, 8, 4, 2, 1) are the same as the sequence generated by `collatz_sequence(5)`. So when generating `collatz_sequence(6)`, we could have just stopped at "5", because we had already established what comes after it. In fact, if we had run `collatz_sequence(3)` before, we could have even stopped at "3". 

This implies that when generating sequences with consecutive starting values, we can always stop within a sequence, once we encounter a value which was the starting value of a previous sequence. 

```{r}
better_solution <- function(x) {

  # create vector in which to store the sequence lengths
  lengths <- rep(0, x)
  
  # generate sequences for different starting values
  for (start in seq(lengths)) {
    
    # setup for a new sequence
    n <- start
    count <- 0
    
    # generate new value as long as:
    #   n > 1: we have not reached the end of the sequence
    #   n >= start: we have not arrived at a previous starting value
    while (n > 1 & n >= start) {
      n <- collatz(n)     # update n
      count <- count + 1  # update the length count  
    }
  
    # add the length of the sequence at whose starting value 
    # we just stopped generating new values in the current sequence
    count <- count + lengths[n]
    
    # store the count in our vector of sequence lengths
    lengths[start] <- count
    
  }
  
  # which starting value produced the longest sequence?
  return(which.max(lengths))

}

better_solution(999999)
```

## Further improvements

However, we can improve our code even further. Notice that the Collatz sequence starting at 1 million has 500,000 as its next value and that the Collatz sequence starting at 999,998 hast 499,999 as its next value. This means, that all sequences with starting values less or equal to 500,000 are really just subsets of the series with starting values greater than 500,000. Therefore, we can start our search at 500,000 instead of 1. Notice also, that after every even number `n` we move closer to zero, because `n` is followed by `n/2`. Conversely, every odd number `n` leads to a greater number `3n+1`. This means that no sequence stops after an odd number. So when faced with an odd number, instead of first computing `3n+1` and in the step after that `(3n+1)/2`, we can skip the first step and compute the latter result right away. Here is the final code:

```{r}
best_solution <- function(x) {

  lengths <- rep(0, x/2)
  
  # start at x/2
  for (start in ceiling(x/2):x) {
    
    n <- start
    count <- 0
    while (n > 1 & n >= start) {
      
      # single step
      if (n %% 2 == 0) {
        n <- n / 2
        count <- count + 1
        
      # double step
      } else {
        n <- (3*n+1) / 2
        count <- count + 2
      }
  
    }
    
    count <- count + lengths[n]
    lengths[start] <- count
  }
  
  return(which.max(lengths))
  
}

best_solution(999999)
```

## Speed comparison

```{r, echo = FALSE}
magnitudes <- 1:15

approach1 <- sapply(magnitudes, function(x) system.time(brute_force(2^x)))
approach2 <- sapply(magnitudes, function(x) system.time(better_solution(2^x)))
approach3 <- sapply(magnitudes, function(x) system.time(best_solution(2^x)))

colors <- c("dimgrey","chocolate1","deepskyblue2")

plot(approach1[3,] ~ magnitudes, 
     type = "l",
     col = colors[1],
     lwd = 2,
     ylab = "Time in s",
     xlab = "Sequences analyzed up to 2^x",
     main = "Comparison of all three methods")

lines(approach2[3,] ~ magnitudes, 
      col = colors[2],
      lwd = 2)

lines(approach3[3,] ~ magnitudes, 
      col = colors[3],
      lwd = 2)

legend("topleft",
       lty = rep(1,3),
       lwd = rep(2,3),
       col = colors,
       legend = c("Brute force","Better","Best"))

magnitudes <- 10:20
approach2 <- sapply(magnitudes, function(x) system.time(better_solution(2^x)))
approach3 <- sapply(magnitudes, function(x) system.time(best_solution(2^x)))

plot(approach2[3,] ~ magnitudes, 
     type = "l",
     col = colors[2],
     lwd = 2,
     ylab = "Time in s",
     xlab = "Sequences analyzed up to 2^x",
     main = "Better vs. Best")

lines(approach3[3,] ~ magnitudes, 
      col = colors[3],
      lwd = 2)

legend("topleft",
       lty = rep(1,2),
       lwd = rep(2,2),
       col = colors[2:3],
       legend = c("Better","Best"))

```

