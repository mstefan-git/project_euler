[["index.html", "Project Euler in R About this book", " Project Euler in R Martin Stefan 2023-03-14 About this book Project Euler is a website that features a series of mathematical problems that can be solved with the help of computer programs. To solve a given problem one can usually come up with a brute-force algorithm. But depending on your computer these “simple” algorithms can take quite some time to find the right answer. The challenge is to write programs that can find the correct answers quickly, i.e. in a matter of seconds on computers for personal use. In blogs and forums one can find many such programs written in C, C#, C++, Java, and Python. Programs written in R are far less common, which is why I’m writing this book. I hope to come up with good R programs for as many of the Project Euler problems as possible. "],["longest-collatz-sequence.html", "14: Longest Collatz sequence Preliminaries Brute force Optimization Further improvements Speed comparison", " 14: Longest Collatz sequence The following iterative sequence is defined for the set of positive integers: \\[ n → ~ n/2 ~~~~~~ (n ~ \\text{is even}) \\] \\[ n → ~ 3n + 1 ~~~ (n ~ \\text{is odd}) \\] Using the rule above and starting with 13, we generate the following sequence: \\[ 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1 \\] It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1. Which starting number, under one million, produces the longest chain? NOTE: Once the chain starts the terms are allowed to go above one million. Preliminaries Let’s begin by writing a simple function which can generates the next value of a Collatz sequence: collatz &lt;- function(n) { if (n %% 2 == 0) { return(n/2) } else { return(3*n+1) } } Here is how it works in action: n &lt;- 13 while (n &gt; 1) { print(n) n &lt;- collatz(n) } ## [1] 13 ## [1] 40 ## [1] 20 ## [1] 10 ## [1] 5 ## [1] 16 ## [1] 8 ## [1] 4 ## [1] 2 Notice that we only generate new values while n &gt; 1. Otherwise, we would get stuck in the cycle $1 → 4 → 2 → 1 →$. Let’s wrap our loop in a function that can generate the entire Collatz sequence for a given starting number: collatz_sequence &lt;- function(n) { numbers &lt;- c(n) while (n &gt; 1) { n &lt;- collatz(n) numbers &lt;- c(numbers, n) } return(numbers) } Here are a few sequences: collatz_sequence(1) ## [1] 1 collatz_sequence(5) ## [1] 5 16 8 4 2 1 collatz_sequence(10) ## [1] 10 5 16 8 4 2 1 Brute force At this stage, we could try to brute-force the problem. I am going to do this for starting values up to 1000: brute_force &lt;- function(x) { max_number &lt;- NULL max_length &lt;- 0 for (i in 1:x) { numbers &lt;- collatz_sequence(i) if (length(numbers) &gt; max_length) { max_length &lt;- length(numbers) max_number &lt;- i } } return(max_number) } brute_force(1000) ## [1] 871 As we can see, among all starting numbers up to 1000, 871 produces the longest Collatz sequence. However, when running this brute-force approach for starting numbers up to 1,000,000, our computer may struggle. Optimization Let’s head back to the start and have a look at the following two sequences: collatz_sequence(5) ## [1] 5 16 8 4 2 1 collatz_sequence(6) ## [1] 6 3 10 5 16 8 4 2 1 Notice how the last six values of collatz_sequence(6) (i.e., 5, 16, 8, 4, 2, 1) are the same as the sequence generated by collatz_sequence(5). So when generating collatz_sequence(6), we could have just stopped at “5”, because we had already established what comes after it. In fact, if we had run collatz_sequence(3) before, we could have even stopped at “3”. This implies that when generating sequences with consecutive starting values, we can always stop within a sequence, once we encounter a value which was the starting value of a previous sequence. better_solution &lt;- function(x) { # create vector in which to store the sequence lengths lengths &lt;- rep(0, x) # generate sequences for different starting values for (start in seq(lengths)) { # setup for a new sequence n &lt;- start count &lt;- 0 # generate new value as long as: # n &gt; 1: we have not reached the end of the sequence # n &gt;= start: we have not arrived at a previous starting value while (n &gt; 1 &amp; n &gt;= start) { n &lt;- collatz(n) # update n count &lt;- count + 1 # update the length count } # add the length of the sequence at whose starting value # we just stopped generating new values in the current sequence count &lt;- count + lengths[n] # store the count in our vector of sequence lengths lengths[start] &lt;- count } # which starting value produced the longest sequence? return(which.max(lengths)) } better_solution(999999) ## [1] 837799 Further improvements However, we can improve our code even further. Notice that the Collatz sequence starting at 1 million has 500,000 as its next value and that the Collatz sequence starting at 999,998 hast 499,999 as its next value. This means, that all sequences with starting values less or equal to 500,000 are really just subsets of the series with starting values greater than 500,000. Therefore, we can start our search at 500,000 instead of 1. Notice also, that after every even number n we move closer to zero, because n is followed by n/2. Conversely, every odd number n leads to a greater number 3n+1. This means that no sequence stops after an odd number. So when faced with an odd number, instead of first computing 3n+1 and in the step after that (3n+1)/2, we can skip the first step and compute the latter result right away. Here is the final code: best_solution &lt;- function(x) { lengths &lt;- rep(0, x/2) # start at x/2 for (start in ceiling(x/2):x) { n &lt;- start count &lt;- 0 while (n &gt; 1 &amp; n &gt;= start) { # single step if (n %% 2 == 0) { n &lt;- n / 2 count &lt;- count + 1 # double step } else { n &lt;- (3*n+1) / 2 count &lt;- count + 2 } } count &lt;- count + lengths[n] lengths[start] &lt;- count } return(which.max(lengths)) } best_solution(999999) ## [1] 837799 Speed comparison "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
